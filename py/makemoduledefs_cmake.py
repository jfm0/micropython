#!/usr/bin/env python

# This pre-processor parses provided objects' c files for
# MP_REGISTER_MODULE(module_name, obj_module, enabled_define)
# These are used to generate a header with the required entries for
# "mp_rom_map_elem_t mp_builtin_module_table[]" in py/objmodule.c

from __future__ import print_function

import re
import io
import os

pattern = re.compile(r"[\n;]\s*MP_REGISTER_MODULE\((.*?),\s*(.*?),\s*(.*?)\)", flags=re.DOTALL)

def find_module_registrations(c_file):
    """Find any MP_REGISTER_MODULE definitions in the provided c file.

    :param str c_file: path to c file to check
    :return: List[(module_name, obj_module, enabled_define)]
    """
    global pattern

    if c_file is None:
        # No c file to match the object file, skip
        return set()

    with io.open(c_file, encoding="utf-8") as c_file_obj:
        return set(re.findall(pattern, c_file_obj.read()))


def generate_module_table_header(modules, f):
    """Generate header with module table entries for builtin modules.

    :param List[(module_name, obj_module, enabled_define)] modules: module defs
    :return: None
    """

    # Print header file for all external modules.
    mod_defs = []
    f.write("// Automatically generated by makemoduledefs.py.\n")
    for module_name, obj_module, enabled_define in modules:
        mod_def = "MODULE_DEF_{}".format(module_name.upper())
        mod_defs.append(mod_def)
        f.write(
            (
                "#if ({enabled_define})\n"
                "    extern const struct _mp_obj_module_t {obj_module};\n"
                "    #define {mod_def} {{ MP_ROM_QSTR({module_name}), MP_ROM_PTR(&{obj_module}) }},\n"
                "#else\n"
                "    #define {mod_def}\n"
                "#endif\n"
            ).format(
                module_name=module_name,
                obj_module=obj_module,
                enabled_define=enabled_define,
                mod_def=mod_def,
            )
        )

    f.write('\n#define MICROPY_REGISTERED_MODULES \\\n')

    for mod_def in mod_defs:
        f.write('            {mod_def} \\\n'.format(mod_def=mod_def))

    f.write('        // MICROPY_REGISTERED_MODULES\n')


def main():
    # Parse arguments
    import argparse

    cmd_parser = argparse.ArgumentParser(
        description="A tool to scan list of files and create moduledefs.h from all MICROPY_REGISTERED_MODULES"
    )
    cmd_parser.add_argument("-i", "--input", help="semicolon delimited list of files paths")
    cmd_parser.add_argument("-o", "--output", help="output file path")
    args = cmd_parser.parse_args()
    
    print(args.input.split(';'))
    
    modules = set()
    for obj_file in args.input.split(';'):
        print(obj_file)
        modules |= find_module_registrations(obj_file)
        
    print(modules)
    print(args.output)
    
    with open(args.output, "w") as f:
        generate_module_table_header(sorted(modules), f)


if __name__ == "__main__":
    main()
